/* SQL Server DBA/Developer Assignment  
Task 1: Database Design and Modelling 
You are tasked with designing a database for a basic online e-commerce platform. The system should manage products, customers, orders, and shipments. Design the necessary tables with --appropriate relationships and attributes. Provide a script to 
Create these tables along with any necessary constraints. */

CREATE TABLE Customers ( 
CustomerId Int Identity(1,1) PRIMARY KEY, 
FirstName VARCHAR(50) NOT NULL, 
LastName VARCHAR(50) NOT NULL, 
EmailId VARCHAR(100) NOT NULL UNIQUE, 
Phone VARCHAR(20), 
Address Varchar(255) 
); 

CREATE TABLE ProductCategories ( 
categoryid INT IDENTITY(1,1) PRIMARY KEY, 
categoryname VARCHAR(100) NOT NULL 
); 

CREATE TABLE Products ( 
ProductId Int Identity(1,1) PRIMARY KEY, 
Name VARCHAR(100) NOT NULL, 
Description Varchar(255), 
Price DECIMAL(14, 2) NOT NULL, 
StockQuantity INT NOT NULL DEFAULT 0, 
CategoryId INT Not Null, 
CONSTRAINT FK_Products_ProductCategory FOREIGN KEY (CategoryId ) REFERENCES ProductCategories(CategoryId) 
); 

CREATE TABLE Orders ( 
OrderId Int Identity(1,1) PRIMARY KEY, 
CustomerId INT NOT NULL, 
OrderDate SmallDatetime Not Null, 
ProductId INT NOT NULL, 
Quantity INT NOT NULL, 
Price DECIMAL(14, 2) NOT NULL, 
Status VARCHAR(20) NOT NULL DEFAULT 'Pending', 
CONSTRAINT fk_Orders_customer FOREIGN KEY (CustomerId) REFERENCES Customers(CustomerId), 
CONSTRAINT fk_Orders_product FOREIGN KEY (ProductId ) REFERENCES Products(ProductId ) 
); 
 
CREATE TABLE Shipments ( 
    ShipmentId Int Identity(1,1) PRIMARY KEY, 
    OrderId INT NOT NULL, 
    ShippingAddress Varchar(255) NOT NULL, 
    ShipmentDate SmallDatetime Null, 
    DeliveryDate SmallDatetime Null, 
    CarrierInfo VARCHAR(255) Null, 
    TrackingNumber VARCHAR(50) Null, 
    CONSTRAINT fk_Shipments_order FOREIGN KEY (OrderId) REFERENCES Orders(OrderId) 
); 
 
 
--Task 2: Data Manipulation  
--a) Populate the tables created in Task 1 with some sample data. 

 -- Insert sample customers 
INSERT INTO Customers (firstname, lastname, emailId, phone, address) VALUES 
('John', 'Doe', 'john.doe@example.com', '1234567890', '123 Main St'), 
('Jane', 'Smith', 'jane.smith@example.com', '0987654321', '456 Oak St'), 
('Bob', 'Johnson', 'bob.johnson@example.com', '1122334455', '789 Pine St'); 

 -- Insert product categories 
INSERT INTO ProductCategories (categoryname) VALUES 
('Electronics'), 
('Books'), 
('Clothing'); 

 -- Insert sample products 
INSERT INTO Products (name, description, price, stockquantity, categoryid) VALUES 
('Laptop', 'High-performance laptop', 999.99, 10, 1), 
('Smartphone', 'Latest model smartphone', 699.99, 20, 1), 
('Fiction Novel', 'Bestselling fiction book', 19.99, 50, 2), 
('T-Shirt', '100% Cotton T-Shirt', 9.99, 100, 3); 

 -- Insert sample orders 
INSERT INTO Orders (customerid, productid, quantity, price, status) VALUES 
(1, 1, 1, 999.99, 'shipped'), 
(1, 2, 2, 699.99, 'pending'), 
(2, 3, 1, 19.99, 'delivered'), 
(3, 4, 3, 9.99, 'pending'); -- Insert sample shipments 

INSERT INTO Shipments (orderid, shippingaddress, shipmentdate, deliverydate, CarrierInfo , trackingnumber) VALUES 
(1, '123 Main St', '2024-08-01', '2024-08-03', 'UPS', '1Z999999'), 
(3, '456 Oak St', '2024-08-02', '2024-08-04', 'FedEx', '2X888888'); 

--b) Write SQL queries to perform the following tasks: 
--Retrieve the top 5 customers who have made the most orders. 

SELECT TOP 5 c.firstname, c.lastname, COUNT(o.orderid) AS ordercount 
FROM Customers c 
JOIN Orders o ON c.customerid = o.customerid 
GROUP BY c.firstname, c.lastname 
ORDER BY ordercount DESC; 

--Display the total revenue generated by each product category. 
SELECT pc.categoryname, SUM(o.quantity * o.price) AS totalrevenue 
FROM ProductCategories pc 
JOIN Products p ON pc.categoryid = p.categoryid 
JOIN Orders o ON p.productid = o.productid 
GROUP BY pc.categoryname; 

--Find the number of orders placed in the last month, broken down by day. 
SELECT CAST(o.orderdate AS DATE) AS orderday, COUNT(o.orderid) AS ordercount 
FROM Orders o 
WHERE o.orderdate >= DATEADD(MONTH, -1, GETDATE()) 
GROUP BY CAST(o.orderdate AS DATE) 
ORDER BY orderday; 

--Calculate the average order value for each customer. 
SELECT c.firstname, c.lastname, AVG(o.price) AS avgordervalue 
FROM Customers c 
JOIN Orders o ON c.customerid = o.customerid 
GROUP BY c.firstname, c.lastname; 
 
 
--Task 3: Database Administration  
--You have a SQL Server instance running with multiple databases. Perform the following tasks: 
 
--a) Write SQL commands to make a FULL backup of the "ShopDB" database and store a compressed backup file in a designated location on disk. 
 
BACKUP DATABASE ShopDB 
TO DISK = 'C:\Backups\ShopDB_FullBackup.bak' 
WITH COMPRESSION,  
     INIT,  -- Overwrites any existing backup file with the same name 
     STATS = 10;  -- Shows progress in 10% increments 


--b) Give example of what could be used to find the most long-running queries. 
-- Query to find long-running queries in SQL Server
SELECT 
    session_id,
    request_id,
    start_time,
    status,
    command,
    wait_type,
    wait_time,
    total_elapsed_time AS execution_duration_ms,
    (SELECT SUBSTRING(text, statement_start_offset / 2, 
        (CASE WHEN statement_end_offset = -1 
            THEN LEN(CONVERT(nvarchar(max), text)) * 2 
            ELSE statement_end_offset END - statement_start_offset) / 2) 
     FROM sys.dm_exec_sql_text(sql_handle)) AS query_text
FROM sys.dm_exec_requests
WHERE total_elapsed_time > 60000  -- Filter to show queries running longer than 60 seconds (60000 milliseconds)
ORDER BY total_elapsed_time DESC;

 
/* 
c) Discuss some common performance tuning techniques in SQL Server. How would 
you identify and address performance bottlenecks? 

: 1. Index Optimization 
Use the Right Indexes: Ensure that you have appropriate clustered and non-clustered 
indexes on frequently queried columns. Also, 
review the execution plans to determine if missing indexes are being suggested. 
Rebuild/Reorganize Indexes: Fragmented indexes slow down queries. Use index 
rebuild or reorganization to maintain optimal performance: 

2. Query Optimization 
Use Execution Plans: Always check the actual or estimated execution plan in SQL 
Server Management Studio (SSMS) to find expensive operations (e.g., full table scans, 
high I/O operations). 
Avoid SELECT *: Only retrieve the columns you need to minimize I/O and memory 
consumption. 
Optimize JOINs and Subqueries: Use efficient join types and replace correlated 
subqueries with more efficient alternatives, like joins or common table expressions 
(CTEs). 

3. Update Statistics 
Statistics help the SQL Server optimizer create efficient execution plans. If statistics 
are outdated, queries may run slower than expected. 

4. Resolve Blocking and Deadlocks 
Blocking: Use DMVs like sys.dm_exec_requests and sys.dm_tran_locks to find blocking 
queries. 

5. Optimize TempDB 
TempDB is a critical resource in SQL Server, used for temporary tables, sorting, and 
more. Performance bottlenecks in TempDB can affect the entire instance. 
Recommendations: 
Use multiple TempDB files (8-12 depending on CPU cores). 
Pre-size TempDB files to avoid frequent file growth. 
Store TempDB on fast storage, such as SSDs. 

Identifying and Addressing Performance Bottlenecks: 
1. Monitor Performance with DMVs: Use DMVs like sys.dm_os_wait_stats, 
sys.dm_exec_query_stats, and sys.dm_exec_requests to identify bottlenecks: 
Wait Statistics (sys.dm_os_wait_stats): Helps you understand where SQL Server is 
spending most of its time. 
Common wait types like PAGEIOLATCH, LCK_MX, and CXPACKET can give you clues 
about IO, locking, or parallelism issues. 

2. Check CPU and Memory Usage: 
High CPU usage could indicate inefficient queries, missing indexes, or parameter 
sniffing issues. 
Memory bottlenecks occur if queries are frequently hitting disk instead of memory (high 
disk I/O). Monitor sys.dm_os_memory_clerks to track memory usage. 

3. Monitor Disk I/O: 
Use performance counters like SQL Server: Buffer Manager and SQL Server: Disk I/O to 
check for high I/O operations, which can lead to slow query performance. High 
reads/write indicate possible index or query inefficiencies. 

4.Use Query Store: 
Query Store helps identify query performance regressions by tracking query plans and 
their performance metrics over time. You can force a previous query plan if a new plan 
performs poorly.


Task 4: Performance Tuning  
 
Identify what could be done to optimize the following stored procedure: 
CREATE PROCEDURE GetOrderDetails 
@OrderID INT 
AS 
BEGIN 
DECLARE @TotalAmount MONEY; 
 
SELECT 
OD.ProductID, 
P.ProductName, 
OD.UnitPrice, 
OD.Quantity, 
OD.UnitPrice * OD.Quantity AS LineTotal 
INTO #TempOrderDetails 
FROM 
OrderDetails OD 
JOIN 
Products P ON OD.ProductID = P.ProductID 
WHERE 
OD.OrderID = @OrderID; 
SELECT @TotalAmount = SUM(LineTotal) FROM #TempOrderDetails; 
SELECT 
ProductID, 
ProductName, 
UnitPrice, 
Quantity, 
LineTotal, 
@TotalAmount AS TotalAmount 
FROM 
#TempOrderDetails; 
DROP TABLE #TempOrderDetails; 
END 
 
Altered procedure:
 
CREATE PROCEDURE GetOrderDetails 
    @OrderID INT 
AS 
BEGIN 
    DECLARE @TotalAmount MONEY; 
 
    -- Single query without temp table 
    SELECT  
        OD.ProductID,  
        P.ProductName,  
        OD.UnitPrice,  
        OD.Quantity,  
        OD.UnitPrice * OD.Quantity AS LineTotal, 
        (SELECT SUM(OD2.UnitPrice * OD2.Quantity) 
         FROM OrderDetails OD2 
         WHERE OD2.OrderID = @OrderID) AS TotalAmount 
    FROM  
        OrderDetails OD 
    JOIN  
        Products P ON OD.ProductID = P.ProductID 
    WHERE  
        OD.OrderID = @OrderID; 
END; 
 
Changes Made: 
 
Single Query Execution: 
 
The total amount (SUM) is calculated in a subquery inside the SELECT statement. This eliminates 
the need for a temp table, improving performance. 
 
Avoid Temp Tables: 
 
We removed the creation of the temporary table and handled the aggregation (SUM) inline. This 
reduces disk I/O and contention in TempDB, making the procedure faster and more efficient. 
Indexes: 
 
Ensure the following indexes are present to optimize the join and filtering: 
 
OrderDetails(OrderID) 
Products(ProductID) 
*/
